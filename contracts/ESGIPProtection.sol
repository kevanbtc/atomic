// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import "@openzeppelin/contracts/access/AccessControl.sol";
import "@openzeppelin/contracts/security/ReentrancyGuard.sol";
import "@openzeppelin/contracts/security/Pausable.sol";
import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
// import "./VaultProofNFT.sol";
// import "./SubscriptionKeyNFT.sol";
// import "./IPFSHashRegistry.sol";
// import "./PGPNotarization.sol";
// import "./SovereigntyProof.sol";

/**
 * @title ESGIPProtection
 * @dev Main controller contract for comprehensive IP protection architecture
 *      integrating VaultProofNFT, SubscriptionKeys, IPFS registry, PGP notarization,
 *      and Unykorn Sovereignty Proof systems
 */
contract ESGIPProtection is AccessControl, ReentrancyGuard, Pausable {
    
    bytes32 public constant OPERATOR_ROLE = keccak256("OPERATOR_ROLE");
    bytes32 public constant IP_MANAGER_ROLE = keccak256("IP_MANAGER_ROLE");
    bytes32 public constant REVENUE_MANAGER_ROLE = keccak256("REVENUE_MANAGER_ROLE");

    // Component contracts - Commented for compilation
    // VaultProofNFT public immutable vaultProofNFT;
    // SubscriptionKeyNFT public immutable subscriptionKeyNFT;
    // IPFSHashRegistry public immutable ipfsHashRegistry;
    // PGPNotarization public immutable pgpNotarization;
    // SovereigntyProof public immutable sovereigntyProof;
    
    // Revenue distribution
    IERC20 public paymentToken;
    address public platformTreasury;
    
    struct IPProtectionPackage {
        uint256 packageId;          // Unique package identifier
        string packageName;         // Human-readable name
        uint256 vaultProofTokenId; // Associated VaultProof NFT
        uint256 subscriptionTier;   // Subscription tier required
        bytes32[] ipfsHashes;       // Protected content hashes
        bytes32[] pgpSignatures;    // PGP signatures for authenticity
        bytes32 sovereigntyProofId; // Sovereignty proof
        uint256 createdAt;          // Package creation timestamp
        address creator;            // Package creator
        bool isActive;              // Package status
        uint256 totalRevenue;       // Revenue generated by this package
        PackageType packageType;    // Type of IP protection
    }

    enum PackageType {
        Individual,     // Single creator protection
        Collaborative,  // Multi-creator protection  
        Institutional,  // Institutional/corporate protection
        OpenSource,     // Open source with attribution
        Commercial      // Full commercial protection
    }

    struct AccessMetrics {
        uint256 totalAccesses;      // Total access count
        uint256 uniqueUsers;        // Unique user count
        uint256 revenueGenerated;   // Revenue from this content
        mapping(address => uint256) userAccessCount;
        mapping(address => uint256) lastAccessTime;
    }

    struct RevenueDistribution {
        address recipient;          // Revenue recipient
        uint256 percentage;         // Percentage share (basis points)
        string role;               // Role in IP creation
        bool isActive;             // Distribution status
    }

    // Storage
    mapping(uint256 => IPProtectionPackage) public protectionPackages;
    mapping(bytes32 => uint256) public contentHashToPackage;
    mapping(uint256 => AccessMetrics) public accessMetrics;
    mapping(uint256 => RevenueDistribution[]) public packageRevenueDistribution;
    mapping(address => uint256[]) public creatorPackages;
    mapping(uint256 => mapping(address => bool)) public packageCollaborators;
    
    uint256 private _packageIdCounter;
    uint256 public constant BASIS_POINTS = 10000;
    uint256 public defaultPlatformFee = 250; // 2.5%

    // Events
    event IPProtectionPackageCreated(
        uint256 indexed packageId,
        address indexed creator,
        PackageType packageType,
        uint256 vaultProofTokenId
    );
    event ContentAccessed(
        uint256 indexed packageId,
        address indexed user,
        uint256 subscriptionTier,
        uint256 timestamp
    );
    event RevenueDistributed(
        uint256 indexed packageId,
        uint256 totalAmount,
        uint256 recipientCount
    );
    event PackageUpdated(uint256 indexed packageId, address indexed updater);
    event CollaboratorAdded(uint256 indexed packageId, address indexed collaborator);

    constructor(
        address _vaultProofNFT,
        address _subscriptionKeyNFT,
        address _ipfsHashRegistry,
        address _pgpNotarization,
        address _sovereigntyProof,
        address _paymentToken,
        address _platformTreasury
    ) {
        require(_vaultProofNFT != address(0), "ESGIPProtection: Invalid VaultProofNFT");
        require(_subscriptionKeyNFT != address(0), "ESGIPProtection: Invalid SubscriptionKeyNFT");
        require(_ipfsHashRegistry != address(0), "ESGIPProtection: Invalid IPFSHashRegistry");
        require(_pgpNotarization != address(0), "ESGIPProtection: Invalid PGPNotarization");
        require(_sovereigntyProof != address(0), "ESGIPProtection: Invalid SovereigntyProof");
        require(_paymentToken != address(0), "ESGIPProtection: Invalid payment token");
        require(_platformTreasury != address(0), "ESGIPProtection: Invalid treasury");

        vaultProofNFT = VaultProofNFT(_vaultProofNFT);
        subscriptionKeyNFT = SubscriptionKeyNFT(_subscriptionKeyNFT);
        ipfsHashRegistry = IPFSHashRegistry(_ipfsHashRegistry);
        pgpNotarization = PGPNotarization(_pgpNotarization);
        sovereigntyProof = SovereigntyProof(_sovereigntyProof);
        paymentToken = IERC20(_paymentToken);
        platformTreasury = _platformTreasury;

        _grantRole(DEFAULT_ADMIN_ROLE, msg.sender);
        _grantRole(OPERATOR_ROLE, msg.sender);
        _grantRole(IP_MANAGER_ROLE, msg.sender);
        _grantRole(REVENUE_MANAGER_ROLE, msg.sender);
    }

    /**
     * @dev Create comprehensive IP protection package
     */
    function createIPProtectionPackage(
        string memory packageName,
        PackageType packageType,
        uint256 requiredSubscriptionTier,
        bytes32[] memory contentHashes,
        string memory tokenURI,
        VaultProofNFT.ProofMetadata memory proofMetadata,
        VaultProofNFT.IPFSManifest memory manifest,
        VaultProofNFT.LicenseTerms memory license,
        VaultProofNFT.RoyaltyInfo memory royalty,
        RevenueDistribution[] memory revenueDistribution
    ) external nonReentrant whenNotPaused returns (uint256 packageId) {
        require(bytes(packageName).length > 0, "ESGIPProtection: Invalid package name");
        require(contentHashes.length > 0, "ESGIPProtection: No content provided");
        require(requiredSubscriptionTier >= 1 && requiredSubscriptionTier <= 4, "ESGIPProtection: Invalid tier");

        // Verify user has required sovereignty level for package type
        if (packageType == PackageType.Institutional) {
            require(
                sovereigntyProof.hasSovereigntyLevel(msg.sender, SovereigntyProof.SovereigntyLevel.Institutional),
                "ESGIPProtection: Insufficient sovereignty for institutional package"
            );
        } else if (packageType == PackageType.Commercial) {
            require(
                sovereigntyProof.hasSovereigntyLevel(msg.sender, SovereigntyProof.SovereigntyLevel.Enhanced),
                "ESGIPProtection: Insufficient sovereignty for commercial package"
            );
        }

        // Create VaultProof NFT
        uint256 vaultProofTokenId = vaultProofNFT.createProof(
            msg.sender,
            tokenURI,
            proofMetadata,
            manifest,
            license,
            royalty
        );

        // Register content in IPFS registry
        for (uint i = 0; i < contentHashes.length; i++) {
            require(contentHashToPackage[contentHashes[i]] == 0, "ESGIPProtection: Content already protected");
        }

        // Create protection package
        packageId = ++_packageIdCounter;
        IPProtectionPackage storage package = protectionPackages[packageId];
        package.packageId = packageId;
        package.packageName = packageName;
        package.vaultProofTokenId = vaultProofTokenId;
        package.subscriptionTier = requiredSubscriptionTier;
        package.ipfsHashes = contentHashes;
        package.sovereigntyProofId = proofMetadata.sovereigntyProof;
        package.createdAt = block.timestamp;
        package.creator = msg.sender;
        package.isActive = true;
        package.packageType = packageType;

        // Map content hashes to package
        for (uint i = 0; i < contentHashes.length; i++) {
            contentHashToPackage[contentHashes[i]] = packageId;
        }

        // Set up revenue distribution
        _setupRevenueDistribution(packageId, revenueDistribution);

        // Initialize access metrics
        AccessMetrics storage metrics = accessMetrics[packageId];
        // Metrics are automatically initialized with zero values

        // Add to creator's packages
        creatorPackages[msg.sender].push(packageId);

        emit IPProtectionPackageCreated(packageId, msg.sender, packageType, vaultProofTokenId);
        return packageId;
    }

    /**
     * @dev Access protected content with subscription verification
     */
    function accessProtectedContent(
        uint256 packageId,
        bytes32 contentHash
    ) external nonReentrant whenNotPaused returns (bool) {
        require(protectionPackages[packageId].isActive, "ESGIPProtection: Package not active");
        require(contentHashToPackage[contentHash] == packageId, "ESGIPProtection: Content not in package");

        IPProtectionPackage memory package = protectionPackages[packageId];
        
        // Check subscription access
        require(
            subscriptionKeyNFT.hasActiveSubscription(msg.sender),
            "ESGIPProtection: No active subscription"
        );
        require(
            subscriptionKeyNFT.getUserAccessLevel(msg.sender) >= package.subscriptionTier,
            "ESGIPProtection: Insufficient subscription tier"
        );

        // Check VaultProof NFT license
        require(
            vaultProofNFT.hasLicense(package.vaultProofTokenId, msg.sender) ||
            vaultProofNFT.ownerOf(package.vaultProofTokenId) == msg.sender,
            "ESGIPProtection: No content license"
        );

        // Update access metrics
        AccessMetrics storage metrics = accessMetrics[packageId];
        if (metrics.userAccessCount[msg.sender] == 0) {
            metrics.uniqueUsers++;
        }
        metrics.userAccessCount[msg.sender]++;
        metrics.lastAccessTime[msg.sender] = block.timestamp;
        metrics.totalAccesses++;

        emit ContentAccessed(packageId, msg.sender, package.subscriptionTier, block.timestamp);
        return true;
    }

    /**
     * @dev Add collaborator to IP protection package
     */
    function addCollaborator(
        uint256 packageId,
        address collaborator,
        uint256 revenuePercentage,
        string memory role
    ) external nonReentrant whenNotPaused {
        require(protectionPackages[packageId].creator == msg.sender, "ESGIPProtection: Not package creator");
        require(collaborator != address(0), "ESGIPProtection: Invalid collaborator");
        require(!packageCollaborators[packageId][collaborator], "ESGIPProtection: Already collaborator");
        require(revenuePercentage <= 5000, "ESGIPProtection: Revenue percentage too high"); // Max 50%

        packageCollaborators[packageId][collaborator] = true;
        
        // Add to revenue distribution
        RevenueDistribution memory distribution = RevenueDistribution({
            recipient: collaborator,
            percentage: revenuePercentage,
            role: role,
            isActive: true
        });
        packageRevenueDistribution[packageId].push(distribution);

        emit CollaboratorAdded(packageId, collaborator);
    }

    /**
     * @dev Distribute revenue for a protection package
     */
    function distributePackageRevenue(uint256 packageId) external onlyRole(REVENUE_MANAGER_ROLE) nonReentrant {
        require(protectionPackages[packageId].isActive, "ESGIPProtection: Package not active");
        
        // Get revenue from subscription purchases and content access
        uint256 availableRevenue = _calculatePackageRevenue(packageId);
        require(availableRevenue > 0, "ESGIPProtection: No revenue to distribute");

        RevenueDistribution[] memory distributions = packageRevenueDistribution[packageId];
        uint256 totalDistributed = 0;
        uint256 platformFeeAmount = (availableRevenue * defaultPlatformFee) / BASIS_POINTS;

        // Distribute to recipients
        for (uint i = 0; i < distributions.length; i++) {
            if (distributions[i].isActive) {
                uint256 recipientAmount = ((availableRevenue - platformFeeAmount) * distributions[i].percentage) / BASIS_POINTS;
                if (recipientAmount > 0) {
                    paymentToken.transfer(distributions[i].recipient, recipientAmount);
                    totalDistributed += recipientAmount;
                }
            }
        }

        // Send platform fee to treasury
        if (platformFeeAmount > 0) {
            paymentToken.transfer(platformTreasury, platformFeeAmount);
            totalDistributed += platformFeeAmount;
        }

        // Update package revenue tracking
        protectionPackages[packageId].totalRevenue += totalDistributed;
        accessMetrics[packageId].revenueGenerated += totalDistributed;

        emit RevenueDistributed(packageId, totalDistributed, distributions.length);
    }

    /**
     * @dev Update package metadata
     */
    function updatePackage(
        uint256 packageId,
        string memory newPackageName,
        bool isActive
    ) external nonReentrant whenNotPaused {
        require(
            protectionPackages[packageId].creator == msg.sender ||
            hasRole(IP_MANAGER_ROLE, msg.sender),
            "ESGIPProtection: Unauthorized"
        );

        IPProtectionPackage storage package = protectionPackages[packageId];
        if (bytes(newPackageName).length > 0) {
            package.packageName = newPackageName;
        }
        package.isActive = isActive;

        emit PackageUpdated(packageId, msg.sender);
    }

    /**
     * @dev Get package information
     */
    function getPackageInfo(uint256 packageId) external view returns (
        IPProtectionPackage memory package,
        AccessMetrics memory metrics,
        uint256 collaboratorCount
    ) {
        package = protectionPackages[packageId];
        metrics = accessMetrics[packageId];
        collaboratorCount = packageRevenueDistribution[packageId].length;
        
        return (package, metrics, collaboratorCount);
    }

    /**
     * @dev Get user's access history for a package
     */
    function getUserPackageAccess(uint256 packageId, address user) external view returns (
        uint256 accessCount,
        uint256 lastAccessTime,
        bool hasAccess
    ) {
        AccessMetrics storage metrics = accessMetrics[packageId];
        return (
            metrics.userAccessCount[user],
            metrics.lastAccessTime[user],
            _checkUserAccess(packageId, user)
        );
    }

    /**
     * @dev Get creator's packages
     */
    function getCreatorPackages(address creator) external view returns (uint256[] memory) {
        return creatorPackages[creator];
    }

    /**
     * @dev Check if content is protected
     */
    function isContentProtected(bytes32 contentHash) external view returns (bool, uint256) {
        uint256 packageId = contentHashToPackage[contentHash];
        return (packageId != 0, packageId);
    }

    /**
     * @dev Administrative functions
     */
    function setDefaultPlatformFee(uint256 newFee) external onlyRole(DEFAULT_ADMIN_ROLE) {
        require(newFee <= 1000, "ESGIPProtection: Fee too high"); // Max 10%
        defaultPlatformFee = newFee;
    }

    function emergencyWithdraw(address token, uint256 amount) external onlyRole(DEFAULT_ADMIN_ROLE) {
        IERC20(token).transfer(platformTreasury, amount);
    }

    function pause() external onlyRole(DEFAULT_ADMIN_ROLE) {
        _pause();
    }

    function unpause() external onlyRole(DEFAULT_ADMIN_ROLE) {
        _unpause();
    }

    /**
     * @dev Internal functions
     */
    function _setupRevenueDistribution(
        uint256 packageId,
        RevenueDistribution[] memory distributions
    ) internal {
        uint256 totalPercentage = 0;
        
        for (uint i = 0; i < distributions.length; i++) {
            require(distributions[i].recipient != address(0), "ESGIPProtection: Invalid recipient");
            require(distributions[i].percentage > 0, "ESGIPProtection: Invalid percentage");
            
            packageRevenueDistribution[packageId].push(distributions[i]);
            totalPercentage += distributions[i].percentage;
        }
        
        require(totalPercentage <= BASIS_POINTS, "ESGIPProtection: Total percentage exceeds 100%");
    }

    function _calculatePackageRevenue(uint256 packageId) internal view returns (uint256) {
        // This would integrate with the subscription system to calculate revenue
        // For now, return the tracked revenue generated
        return accessMetrics[packageId].revenueGenerated;
    }

    function _checkUserAccess(uint256 packageId, address user) internal view returns (bool) {
        IPProtectionPackage memory package = protectionPackages[packageId];
        
        if (!package.isActive) return false;
        
        // Check subscription
        if (!subscriptionKeyNFT.hasActiveSubscription(user)) return false;
        if (subscriptionKeyNFT.getUserAccessLevel(user) < package.subscriptionTier) return false;
        
        // Check VaultProof license
        return vaultProofNFT.hasLicense(package.vaultProofTokenId, user) ||
               vaultProofNFT.ownerOf(package.vaultProofTokenId) == user;
    }
}